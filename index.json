[{"categories":[],"content":"A few years ago I realized that if I’m too busy to take something on, I shouldn’t say “I don’t have the time”. In fact, I often do have the time. It’s not that hard to squeeze in some extra time for someone. 几年前我意识到，如果我太忙没法做某些事情，我不应该说“我没有时间”。事实上，我经常有这个时间，为某些人挤出一些额外的时间并不难。 What I don’t have – and what I can’t squeeze in – is more attention. Attention is a far more limited resource than time. So what I should say is “I don’t have the attention”. I may have 8 hours a day for work, but I probably have 4 hours a day for attention. 我所没有的——也是我不能挤出来的——是更多的注意力。注意力是一种远比时间更有限的资源。所以我应该说的是“我没有注意力”。我可能每天有8小时用来工作，但我可能有四小时能保持专注。 One summer, a guy wrote me out of the blue asking if he could intern for me. His email was great – clear, thoughtful, kind, inviting, confident but not pushy, and not too long (but long enough to say what he had to say without leaving anything out). He was studying at Harvard Business School and was going to be back in Chicago that summer. 一个夏天，一个人突然给我写信，问我他是否可以来我这实习。他的电子邮件写的很好——清晰，周到，亲切，有吸引力的，自信但不咄咄逼人 ，而且不长（但足够说明他想要说的且没有遗漏任何东西）。他正在哈佛商学院学习，并且那个夏天会回到芝加哥。 He asked if he could swing by and say hi. His email made it easy for me to say yes. So he did, and we had a great session. We spent maybe an hour or so together. I learned about his background, what kind of stuff he was interested in, what he wanted to learn, what he could teach us, etc. Then we riffed on a few ideas. It was natural, flowing, effortless. Really promising. 他问我他是否可以顺便过来打个招呼。他的电子邮件让我很容易就答应了。于是他来了，并且我们进行了一次很好的会谈。我们在一起花了大概一小时左右的时间。我了解了他的背景，他对什么样的东西感兴趣，他想学什么，他能教我们什么，等等。 然后我们重复（讨论）一些想法。这个（过程）是自然的，流畅的，不费力的。很有希望。 Then I told him I’d think a few things over and get back to him soon. He checked in a few weeks later, and I said I’d get back to him soon again. And I didn’t. 之后我告诉他我会考虑一些事情并尽快回复他。几周后他来检查（了解情况），然后我再次告诉他我会尽快回复，但我没有。 A month or so after that I wrote him and told him I was really sorry. I’d mislead him – and myself – thinking I had enough time to take on a intern that summer. I wanted to, I really liked him, I thought he’d be great, but I just didn’t have as much time as I thought I had to even consider it more and line up work and spend time with him, etc. 过了一个月左右，我写信给他并告诉他我真的很抱歉。我误导（耽误）了他——也耽误了我自己——认为我有足够的时间在那个夏天带一下实习生。我想这样，我真的喜欢他，我认为他很不错，但我只是没有我想我有的那么多的时间， 甚至是多考虑一下这件事（的时间），安排工作（的时间），花时间和他一起，等等。 But really, as I thought about it, I realized I had the time. Every day is the same 24 hour cycle. Every workday around 8 hours. Surely I could have found even 20 minutes a day to work with him. But it wasn’t that. It wasn’t that I couldn’t find the time. I couldn’t find the attention — especially sustained attention. 但是真的，当我想到这件事时，我意识到我是有时间的。每天都是相同的24小时循环。每个工作日大约是8小时。我当然可以每天找出20分钟的时间来和他一起工作。但并不是这样。不是我找不到时间，我是找不到注意力——特别是持续的注意力。 My mind fills up with a few key projects and that’s it. I’m absorbed by those. That’s where my attention is. Had I made 20 minutes here and there for him, I’d be physically present in that moment, but mentally I’d be elsewhere. And that’s not fair to either of us. 我的脑海里充满了几个关键的项目，就是这样。我被他们所吸引了。这就是我注意力所在的地方 。如果我零零散散地为他腾出20分钟的时间，那时候我外在上是在那里的，但我精神上会在其他地方，这对我们两个中的任何一个都不公平。 Time and attention aren’t the same thing. They’re barely related. 时间和注意力并不是一个东西，他们几乎没有关联 out of the blue 从天而降 intern 实习 inviting 有吸引力 pushy 执意强求的，爱出风头的；野心勃勃的，有进取心的 swing 摆动 swing by somewhere 顺便去了某处 session 会话，会谈 sustain 坚持，支持 sustained 持续的 here and there 到处 barely 几乎不 虚拟语气省略倒装 Had I made 20 minutes here and there for him, I’d be physically present in that moment, but mentally I’d be elsewhere. And that’s not fair to either of us. 所有翻译内容仅供个人学习使用，如涉及侵权，请联系本人删除。 All translated content is for personal study only, in case of infringement, please contact me to delete. ","date":"2023-05-21","objectID":"/%E7%BF%BB%E8%AF%91-%E6%97%B6%E9%97%B4%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":[],"title":"The difference between time and attention（时间和注意力的区别）| 翻译","uri":"/%E7%BF%BB%E8%AF%91-%E6%97%B6%E9%97%B4%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":[],"content":"Like most people in tech, I have been bombarded lately with a ton of “AI stuff”. Articles upon articles of opinions and rants. Papers and videos on various subjects from technical architectures to societal impacts and beyond. 像大多数科技界人士一样，我最近被大量“AI的东西 ”所轰炸。（有）一篇又一篇的带有各种观点和争论的文章，（也有）从技术架构到社会影响等各种主题的论文和视频。 While one must preserve a level-headed view on all these subjects and opinions, two related topics make me sad and annoyed at the same time. Namely: 虽然一个人需要对各种主题和观点保持冷静，但有两个相关的话题让我同时感觉难过和恼火，即： AI won’t replace people. People using AI will replace people, and, Prompt engineering is the future. Everyone should learn it to be competitive. So let’s explore these two topics in a bit of detail. AI不会取代人类。使用AI的人才会取代别人，以及，提示工程是未来趋势。所有人都要学习使用AI来保持竞争力。因此，让我们来详细一点地探讨一下这两种话题。 ","date":"2023-05-14","objectID":"/%E7%BF%BB%E8%AF%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%98%AF%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84/:0:0","tags":[],"title":"Why Prompt Engineering Is Nonsense 为什么（计算机上的）提示工程是没有意义的 | 翻译","uri":"/%E7%BF%BB%E8%AF%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%98%AF%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84/"},{"categories":[],"content":"People using AI will replace people not using AI 会使用AI的人会取代不使用AI的人。 I believe there are a few reasons why this topic keeps re-appearing in all discussion threads. The most likely one though is “forced optimism”. It is hard to believe that people don’t feel anxious about these massive shifts – after all, it’s human nature to feel anxiety towards change (of any kind). It becomes easier to tell oneself “I will adapt, it will be good for me. I have control.” We, humans, tend to overestimate how much control we have in any given situation, and this is a perfect example. 我相信这个话题会在所有讨论趋势中持续重复出现是有几个原因的。 最有可能的一个是“强迫乐观”。很难相信人们不会对这些巨大的改变感到焦虑——毕竟，对（任何形式的）变化感到焦虑是人们的天性。这更容易促使人们告诉自己“我会适应的，这会对我好，我有控制权。”我们人类倾向于高估我们在任何情况所拥有的控制权（控制局面的能力），这就是一个很好的例子。 On the other hand, there is a clear underestimation of the force and speed of the changes. There have been numerous charts regarding exponential growth and linear thinking, but here’s a reminder (courtesy of Singularity Hub): 另一方面，变化的力量和速度被明显低估了。有许多关于指数增长和线性思考的图表，但这里有一个提醒（由Singularly Hub提供）： Exponential growth suprise factor 指数增长的意外因素 I think most people are betting that “next ChatGPT” will only be a bit better than the current version, and not much better. At this moment I cannot say which way things will go, but I will bet myself that it’s going to be much better. 我认为大多数人都打赌所谓“下一个ChatGPT”只会比现在这个版本的好一点点，而不会好特别多。此时此刻我不敢说事情会走向何方，但我敢打赌它会变得（比现在）好得多。 And finally, I will make a somewhat objectionable comparison of this phrase to victim blaming. If you lost your job, is not because there’s no need for your services anymore, but rather - it’s your fault, you could not keep up. This is a very dangerous mode of thinking that I think does a great disservice to everyone, including the people propagating this nonsense. You should know better! 最后，我要打一个可能不太恰当的比较，这段话（会使用AI的人会取代不适用AI的人）和受害者责备。如果你失去了你的工作，不是因为不再需要你的服务，而是因为——这是你的错，你跟不上（时代/进度）。这是一种非常危险的思维方式，我认为它对每个人都造成了很大的伤害，包括传播这些胡言乱语的人。你们应该更清楚！ So how do we put all these things together and what can we say about this line of reasoning? Well, if you’ve been reading up until this point you already know what I am going to say: “No, AI will replace your job. Not people using AI.”. For jobs that don’t require humans for liability purposes (e.g. doctors, lawyers, licensed engineers) there’s hard to see how one using AI is better than simply AI. 那么我们如何将所有这些东西放在一起，我们可以对这条推理线说些什么呢？好吧，如果你坚持读到这里，你已经知道我要说什么了：”不，AI会取代你的工作，而不是使用AI的人（取代你的工作）。“对于不是以（负）责任为目的的工作（如医生、律师、有执照的工程师），很难看到使用人工智能的人比单纯的人工智能（做的）更好。 I must reiterate that I am not interested in the very short-term future (1 to 2 years). It is not relevant. One cannot buy a house, save money or grow a family in 1 to 2 years. Go ahead, use AI to help you stay afloat for a couple of years. It won’t matter after that, when YOU are the slowest component of the chain and replacing YOU will improve the productivity of the entire process. 我必须重申我对短期的未来（一到两年）并不感兴趣。这是不相关的。一个人不可能在一到两年内买房，存钱或者组建一个家庭。继续吧，使用AI来帮助你维持几年的生计。在这之后就没事了，当你是整个（生产） 链上最慢的那部分时，取代你将提高整个过程的生产力。 Here’s an obligatory meme that I find best relays the message: 这是我发现最能传达（我想表达的）信息的时髦的网图。 ","date":"2023-05-14","objectID":"/%E7%BF%BB%E8%AF%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%98%AF%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84/:0:1","tags":[],"title":"Why Prompt Engineering Is Nonsense 为什么（计算机上的）提示工程是没有意义的 | 翻译","uri":"/%E7%BF%BB%E8%AF%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%98%AF%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84/"},{"categories":[],"content":"Prompt engineering is the future 提示工程是未来趋势 This is the most misguided thing I have seen in a long time and I wish people would be more careful about taking this seriously. I want to explore a bit the absurdity of the following statement (seen on LinkedIn): 这是我很长一段时间以来看到的最具有误导性的事情，并且我希望人们能更小心，更严肃地谈论这个话题。 我想要探讨一下以下言论的荒谬之处。（领英上看到的） Prompt Engineering: one of the hottest🔥 and most rewarding🤑 fields in tech 提示工程：最热门和最有价值的技术领域之一。 My response to the original poster was that it is not engineering and it’s not a field in tech. And don’t get me started with the rewarding part. 我对原来的帖子回应是，它不是工程学，也不是一个技术领域。而且更不要让我开始说关于价值的部分。 So why isn’t it engineering? Well, is asking a question “engineering”? Excuse me for being pedantic but from what I’ve learned it’s part of the field of “philosophy”. There is no engineering involved. And even if there is “skill” required to formulate a well-structured question for the LLM, that is not an engineering pursuit. 所以为什么它不是工程学？好吧，问一个问题是”工程“吗？原谅我卖弄学问，但根据我所学到的，这是属于哲学的一部分。并不包含工程。即使需要这样一个”技能“来为LLM（large language model 大语言模型）制定一个结构良好的问题。这也不是一个工程方面的追求。 Now, I don’t want to linger on technicalities over the naming of this process. What interests me instead is the amount of knowledge required to formulate these questions and I would guess it’s very little. You see, calling it “engineering” creates wrong expectations. One can argue that it tries to convince people that it’s a marketable skill - a skill that they can use for employment security, and, in some cases give an advantage. 现在，我不想纠缠于这个关于这个过程的命名的技术问题。我感兴趣的反而是 制定这些问题所需要的知识量，我猜它需要得非常少。你看，把它称为“工程”产生了错误的期望。一个人可以争辩说，它视图说服人们这是一个有市场的技能——一种可以用来保障它们就业的技能，并且，在某些情况下会带来优势。 On a related note, the type of questions one asks are intimately tied to the architecture of the underlying model one uses. The alignment process used by each model provider is different and changes over time to make it better at understanding even the vaguest of questions. So this purported “skill” is nothing but a temporary adjustment in how one asks questions - a process that is bound to change often. 与之相关的是，一个人所问的问题的类型与所使用的基础架构密切相关。每个模型提供者所使用的调整过程是不同的，并且会随着时间的推移而改变，使得模型甚至对最模糊的问题有更好的理解。 所以这个所谓的“技能”啥也不是，只不过是一个关于一个人如何问问题的临时的调整——这个过程必然会经常改变的。 My advice to people is this: do not take these “skills” too seriously. I know these are uncertain times and things are changing fast. One needs to be very careful not to be left behind. But this time, it’s out of your control. One cannot do much to stay relevant and these “new skills” that are being sold to you are just red herrings. 我给大家的建议是：别把这些”技能“太当回事。我知道这是一个不确定的时代，事情变化得很快。人们需要非常小心，以免被甩在后面。但是这次，这不在你的控制范围内。对于保证相关（与时俱进），人们能做的太少，而这些卖给你的”新技能“只不过是熏青鱼（让你转移注意力的话题）。 所有翻译内容仅供个人学习使用，如涉及侵权，请联系本人删除。 All translated content is for personal study only, in case of infringement, please contact me to delete. bombard 轰炸 rant 咆哮 preserve 保持 level-headed 冷静的 Exponential 指数的 objectionable 有异议的 objection 反对 victim 受害者 disservice 伤害 liability 责任，义务 reiterate 重申 afloat 经济上周转得开的，不欠债的 obligatory 有义务的，强制性的 pedantic 迂腐的，卖弄学问的 formulate 制定的 pursuit 追求 ","date":"2023-05-14","objectID":"/%E7%BF%BB%E8%AF%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%98%AF%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84/:0:2","tags":[],"title":"Why Prompt Engineering Is Nonsense 为什么（计算机上的）提示工程是没有意义的 | 翻译","uri":"/%E7%BF%BB%E8%AF%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%98%AF%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84/"},{"categories":[],"content":"When you were a kid, it seemed like you could walk up to just about anybody and be best friends the next minute. But somewhere along the long, winding road to adulthood, making new friends became an impossibly hard thing to do. 当你还是一个孩子时，似乎你可以走到任何人身边，并在下一分钟成为最好的朋友。但在通往成年之路的漫长曲折的某个地方，交新朋友变成了一件不可能的事情。 Well according to psychologist and University of Maryland professor Marisa G. Franco, that’s because as you get older, making friends no longer happens organically. 好吧，根据Maryland大学的教授，心理学家Marisa G. Franco所说，这是因为当你长大后，交朋友不再自然而然地发生。 “Sociologists have kind of identified the ingredients that need to be in place for us to make friends organically, and they are continuous unplanned interaction and shared vulnerability,” says Franco, who is writing a book on making friends as an adult. “But as we become adults, we have less and less environments where those ingredients are at play.” ”社会学家已经确定了一些我们自然而然交朋友所需的因素，他们是持续地没有目的地互动和共同的弱点（脆弱性）“，正在写一本关于成人交朋友的书的Franco说，“但是当我们长大成人，我们越来越缺少让这些因素发挥作用的环境。“ If we continue to expect friendships to happen naturally like they did when we were kids, we run the risk of waiting for something that might never come. Being intentional is essential, she says. Research shows those who view friendships as something that happens because of luck are lonelier later on in life, she says, “and those who see it as something that happens based on effort are less lonely years later.” 如果我们继续期望友谊像我们小时候那样自然发生，我们就会冒一种等待可能永远不会发生的事情的风险。（在交朋友这件事上）刻意一点是有必要的。她还说，研究表明，那些认为友谊是一种因为运气而发生的人，（在有这种想法）之后会感觉更加孤独，而那些认为友谊是一种依靠努力发生的人之后会比较不觉得孤独一些。 Juliana Clark, a 25-year-old audio producer living in Los Angeles, says that while she’s been able to make a few friends here and there, she is mostly looking for a community. Spending a few minutes with a new acquaintance doesn’t usually leave her with a feeling that a new friendship is blossoming. Juliana Clark是一个25岁的住在洛杉矶的音频制作人，她说虽然她能够或多或少交到一些朋友，但她主要是在寻找一个团体（共同体）。与刚认识的人相处几分钟通常不会让他感觉友谊正在开花结果。 “I’m really more interested in kind of creating a sustainable community that will last,” she says, “especially since at least so many of the friendships that I’ve made just in my life have kind of had these common experiences anchoring them.” “我真正更加感兴趣的是创建一种可持续的，互相支撑的团体（社区）\"，她说，“特别是因为至少我一生中结交的友谊都有些这样的共同的经历来巩固他们（指友谊）。” According to Franco, the key to building a community of friends is setting up planned interactions, like regular group events or rotating potlucks. 根据Franco所说，建立朋友圈的关键是举行一些有计划的活动（互动），比如定期的团体活动或者轮流聚餐。 “Researchers also find that when we develop groups, our friendships are more sustainable than they are with individuals. Because there’s multiple touch points now, right? Someone else in the group could reach out to all of us, and then we all keep in touch,” she notes. “研究人员还发现当我们发展集体活动，我们的友谊比那些以个人形式发展的友谊更可持续。因为现在有多种接触点（接触方式），对吗？在团体里的其他人可以联系到我们所有人，之后我们所有人都保持联系。“她说。 If that sounds terrifying to you, Franco says it’s crucial to assume that people already like you. Assume any meet ups will go well, she says, which in turn will help build up your confidence. “We all have this tendency to think we’re more likely to be rejected than we actually are,” she says. 如果这听起来让你感觉害怕，Franco说假设其他人已经喜欢你是至关重要的。她说，假设所有的聚会都进行得很顺利，这样会反过来帮助你建立信心。 她说：”我们都有这样一个倾向，认为我们比我们实际上更可能被拒绝（认为我们可能会被拒绝，而实际上不是这样）。“ How age, gender play a role in forming friendships 年龄，性别在友谊的形成中扮演了什么样的角色 As we move through life, our struggles change. People in their 30s and their 40s have voiced how having kids or moving to a new city made it tough for them to form connections. 随着我们在生活中前进，我们所奋斗的事情也会发生变化。30几岁的人和40几岁的人表示，有了孩子或者搬到一个新的城市如何使得他们产生联系变得困难。 Kate Hickcox, 42, moved to Maine from New York City with her husband in 2018. The mom of two young children says she and her husband still haven’t met any new friends in their more rural life. The pandemic worsened the situation since making plans was off the table. Kate Hickcox，42岁，和她的丈夫在2018年从纽约搬到Maine。这位两个年轻孩子的妈妈说在她们这段更乡村的生活中，她和她的丈夫仍然没有遇到其他的新朋友。疫情加重了这个情况，因为他们无法制定计划。 “I’m also a city girl. I often feel like an ou","date":"2023-05-13","objectID":"/%E7%BF%BB%E8%AF%91-%E6%88%90%E5%B9%B4%E5%90%8E%E4%BA%A4%E6%9C%8B%E5%8F%8B%E5%A4%AA%E9%9A%BE%E4%BA%86/:0:0","tags":[],"title":"You're not uncool. Making friends as an adult is just hard(不是你的问题，成年后交朋友太难了) | 翻译","uri":"/%E7%BF%BB%E8%AF%91-%E6%88%90%E5%B9%B4%E5%90%8E%E4%BA%A4%E6%9C%8B%E5%8F%8B%E5%A4%AA%E9%9A%BE%E4%BA%86/"},{"categories":["codeforces"],"content":"contest link ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:0","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"A 题意 给一个10个字母的字符串，问和codeforces相比有几个字母不同 解析 逐字比较即可 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:1","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"B 题意 给一个二进制数组，问最长的连续的0是多少 解析 枚举寻找 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:2","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"C 题意 一个人可以花时间读【00，01，10，11】四种书，问达成【11】所需要的最少时间是多少？其中【11】既可以通过直接读【11】得到，也可以通过分别读【01，10】得到。 解析 分别枚举两种方式的最少时间，取最小值。 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:3","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"D 题意 设一块金子重量是3x，这块金子能够以分成x和2x的方式被切割，比如6可以被切割为2和4。给定一个n和m，问重为n的金子能否通过切割得到重为m的金子？ 解析 根据题意dfs搜索答案即可，时间复杂度为O($n^{log_23} \\times t$) #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; bool solve(int n, int m) { if(n == m) return true; else { if(n % 3 == 0) { return (solve(n / 3, m) || solve(n / 3 * 2, m)); } else { return false; } } } int main() { int t; cin \u003e\u003e t; while (t --) { int n, m; cin \u003e\u003e n \u003e\u003e m; if(solve(n, m)) cout \u003c\u003c \"yes\"; else cout \u003c\u003c \"no\"; cout \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:4","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"E 题意 给一个n*m的数组，每个数字表示湖的深度，深度为0的地方代表陆地，问最大容量（所有深度之和）的湖有多大？ 解析 用bfs找一下，被访问到的就标记一下，累加一下答案，然后比较最大值即可。 小结一下pair的使用，在一些二元组的场合还是挺方便的。 定义 pair\u003cint,int\u003e p; 嵌套定义 queue\u003cpair\u003cint, int\u003e\u003e q; 生成 make_pair(x,y); 使用 p.first // 第一个变量 p.second // 第二个变量 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; const int x[4] = {0,0,-1,1}; const int y[4] = {1,-1,0,0}; int a[1010][1010]; bool b[1010][1010]; int solve() { int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i ++) { for(int j = 1; j \u003c= m; j ++) { cin \u003e\u003e a[i][j]; if(a[i][j] != 0) b[i][j] = true; else b[i][j] = false; } } queue\u003cpair\u003cint, int\u003e\u003e q; int ans = 0; for(int i = 1; i \u003c= n; i ++) { for(int j = 1; j \u003c= m; j ++) { if(!b[i][j]) continue; int now = 0; q.push(make_pair(i, j)); b[i][j] = false; while(!q.empty()) { pair\u003cint, int\u003e p; p = q.front(); now += a[p.first][p.second]; q.pop(); for(int k = 0; k \u003c 4; k ++) { int x1 = p.first + x[k]; // 这里i，j弄错了 int y1 = p.second + y[k]; // 这里first，second弄错了 if(x1 \u003e=1 \u0026\u0026 x1 \u003c= n \u0026\u0026 y1 \u003e=1 \u0026\u0026 y1 \u003c= m \u0026\u0026 b[x1][y1]) { q.push(make_pair(x1, y1)); b[x1][y1] = false; } } } ans = max(ans, now); } } return ans; } int main() { int t; cin \u003e\u003e t; while(t --) { cout \u003c\u003c solve() \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:5","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"F 题意 有一棵树，这棵树只有三层节点，其中父节点只有一个，子结点有x个，孙子结点有y个，给你每个点之间的连接关系，求x和y的值 解析 注意到孙子结点的度只有1，找到度为1的点，然后遍历上去求子节点和父节点的度即可。 虽然父节点的度也可能为1，但其实不影响答案。因为当父节点度为1时，树翻转过来的结构也还是一样的。 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; int x,y; int solve() { int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e a[n + 10]; int num[n + 10]; memset(num, 0 ,sizeof(num)); for(int i = 1; i \u003c= m; i ++) { int u,v; cin \u003e\u003e u \u003e\u003e v; a[u].push_back(v); a[v].push_back(u); num[u] ++; num[v] ++; } for(int i = 1; i \u003c= n; i ++) { if(num[i] == 1) { for(int j = 0; j \u003c a[i].size(); j ++) { if(num[a[i][j]] != 1) { y = num[a[i][j]] - 1; for(int k = 0; k \u003c a[a[i][j]].size(); k ++) { if(num[a[a[i][j]][k]] != 1) { x = num[a[a[i][j]][k]]; } if(y == 0) x = 1; } } } break; } } } int main() { int t; cin \u003e\u003e t; while(t --) { x = 0, y = 0; solve(); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; } return 0; } 看了一下官方题解的做法，也是相近的，就是计算每个点的度，度为x的点只有1个，度为y+1的点有x个，度为1的点有x*y个。 不过当x=y+1的时候有特殊情况。度为y+1的点有x个，度为1的点有x*y个。 根据这两种情况解二元方程就可以了。 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:6","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"G 题意 有一些罐头按序号从上到下堆成金字塔形，拿掉其中一个，在他上面的罐头都会倒塌，问拿掉那个罐头后倒塌的所有的序号的平方和时多少？ 解析 一开始我是一位搜索能够的，直接写了个搜索，结果T了，然后比赛时间也到了，就结束了。然后定睛一看O($n \\times t$)已经到$10 ^ 9$的数量级了，一般情况超过了$10^8$就会超时，记错了。后面一看完全可以写个dp，状态转移方程也很简单，运用了一下容斥原理也可以得到。 dp [i，j] 表示推倒第i行第j个罐子所得到的序号平方和，状态转移方程为： $$dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + a[i][j] * a[i][j] - dp[i - 2][j - 1]$$ 之前写的搜索就是注释的那些，其实写记忆化搜索也可以减少重复查询，应该也能过，不过懒得写了。 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; vector\u003cLL\u003e a[2100]; LL dp[2100][2100]; bool b[2100][2100]; // LL cal(int x, int y) // { // if(!b[x][y]) return 0; // if(x \u003c 1 || y \u003e= a[x].size() || y \u003c 0) return 0; // LL ans = a[x][y] * a[x][y]; // b[x][y] = false; // 这个弄反了？ // if(b[x - 1][y]) ans += cal(x - 1, y); // if(b[x - 1][y - 1]) ans += cal(x - 1, y - 1); // // 对于dfs，计算过程不写在return里方便debug // return ans; // } LL solve() { int n; cin \u003e\u003e n; memset(b,true,sizeof(b)); for(int i = 1; i \u003c= 2023; i ++) { for(int j = 0; j \u003c a[i].size(); j ++) { if(a[i][j] == n) { // return cal(i ,j); return dp[i][j]; } } } } int main() { LL p1,p2; p1 = p2 = 0; for(int i = 1; i \u003c= 2023; i ++) { p1 ++; for(int j = 0; j \u003c p1; j ++) { p2 ++; a[i].push_back(p2); } } dp[1][0] = 1; for(int i = 2; i \u003c= 2023; i ++) { dp[i][0] = dp[i - 1][0] + a[i][0] * a[i][0]; for(int j = 1; j \u003c a[i].size(); j ++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + a[i][j] * a[i][j] - dp[i - 2][j - 1]; } } int t; cin \u003e\u003e t; while(t --) { cout \u003c\u003c solve() \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:7","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"H 这道题是赛后补上的，对于这种用到位运算的题一直没啥头绪，虽然题目意思很简单 题意 给一个包含n个正整数的数组，这个数不超过63。可以任去一段子序列，对序列内的数进行AND（按位与），问运算后的二进制数刚好有k个1的方案有几种？ 解析 由于数组的数非常小，可以考虑用dp直接存每个数的方案数,然后再求和刚好有k个1的数的方案数。 dp[i,j]表示数组取前i个数能得到结果为j的方案数 那么分三种情况 直接在第i个数开始一个新子序列，那么 $dp[i][a[i]] ++$ 我们不取第i个数做按位与，那么$dp[i][a[i]] += dp[i - 1][a[i]]$ 我们取第i个数做按位与，那么$dp[i][a[i] \u0026 j] += dp[i - 1][j]$ __builtin_popcount(mask) // 就是求这个数的二进制表达有多少个1的一个函数 一般碰到这种要mod大数字的题，我都会考虑采用long long，但看题解非常自信的没有用，每一处可能超的地方都做好了mod限制，这是我需要学习的地方。 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; const int mod = 1e9 + 7; int solve() { int n, k; cin \u003e\u003e n \u003e\u003e k; vector\u003cint\u003e a(n + 1); vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(1 \u003c\u003c 6, 0)); for(int i = 1; i \u003c= n; i ++) { cin \u003e\u003e a[i]; for(int mask = 0; mask \u003c (1 \u003c\u003c 6); mask ++) { dp[i][mask] += dp[i - 1][mask]; if(dp[i][mask] \u003e= mod) dp[i][mask] -= mod; dp[i][mask \u0026 a[i]] += dp[i - 1][mask]; if(dp[i][mask \u0026 a[i]] \u003e= mod) dp[i][mask \u0026 a[i]] -= mod; } dp[i][a[i]] = (dp[i][a[i]] + 1) % mod; } int ans = 0; for(int mask = 0; mask \u003c (1 \u003c\u003c 6); mask ++) { if(__builtin_popcount(mask) == k) { ans = (ans + dp[n][mask]) % mod; } } return ans; } int main() { int t; cin \u003e\u003e t; while(t --) { cout \u003c\u003c solve() \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:8","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["翻译"],"content":"I recently shifted from my home town to Delhi – the country’s capital. When I was in my town, I missed Delhi. When I am in Delhi now, I miss my home town. 最近我离开家乡来到德里——国家的首都。当我在我的家乡时，我想去德里，可当我真正在德里时，我想念我的家乡。 You ask why? Why I wanted to move to Delhi is a story for another day. But I will tell you why I desire to move back to my small and still home town. 你问我为什么？ 我为什么想去德里改天再说吧，但是我想告诉你的是我为什么想从德里回到我那小小的平静的家乡。 Cities and towns have souls of their own. You don’t just live in them; you live with them. If you like their company, things will align themselves to make you successful and happy. But if you don’t like the company, you will keep bumping into the wrong things. Once I liked Delhi’s company. But I am not enjoying it anymore because The bigger the city, the faster its manners of living. When you physically live around people who are in your profession, you constantly feel more competition. Big towns have big people. The bigger the people, the more their gravitational force. My Delhi friends are doing their own big things. And I get sucked into those things willingly or non-willingly. 大城市和小城镇有着他们自己的灵魂。你不是住在他们那里，而是和他们生活在一起。如果你喜欢他们的陪伴，你想做的事情就会和你步调一致，从而使你事业有成，生活愉快。但是如果你不喜欢他们的陪伴，你会不断地遇上那些错误的事情。 我曾喜欢过德里的陪伴，但我现在已经不喜欢了，因为 城市越大，它的生活方式越快。 当你的周围都是和你一样的同行，你会不断地感受到更多的竞争。 大城市里有大人物。这个人越“大”，他就有更多的“地心引力”。我在德里的朋友们总是在做他们自己的“大”事，可我总是自愿或不自愿地被牵扯进这些事情中。 I agreed with Naval Ravikant when he said, “Choosing what city to live in can almost completely determine the trajectory of your life, but we spend so little time trying to figure out what city to live in.” Many people think of moving to a big, more vibrant city when they read Naval’s quote. But I think of moving to a small town. A town that is closer to nature. A town where I can get closer to myself than to other people. 我同意Naval Ravikan（一个企业家）说的，“选择在什么样的城市生活几乎可以完全决定你的生活轨迹，但我们总是不假思索地就决定了我们想要居住的城市。” 当读到Naval的这句话时，很多人想到的是去一个大的，更生机勃勃的城市。但是我想到的是去一个小城镇，一个更接近自然的城镇，一个我可以更接近自我而不是他人的城镇。 所有翻译内容仅供个人学习使用，如涉及侵权，请联系本人删除。 All translated content is for personal study only, in case of infringement, please contact me to delete. align bump manner of livings profession trajectory vibrant ","date":"2023-05-12","objectID":"/%E7%BF%BB%E8%AF%91-%E5%AE%B6%E4%B9%A1/:0:0","tags":[],"title":"Town(家乡) | 翻译","uri":"/%E7%BF%BB%E8%AF%91-%E5%AE%B6%E4%B9%A1/"},{"categories":null,"content":"请洒潘江，各倾陆海云尔 ","date":"2023-03-08","objectID":"/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/hello-world/"}]