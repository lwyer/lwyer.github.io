[{"categories":["codeforces"],"content":"contest link ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:0","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"A 题意 给一个10个字母的字符串，问和codeforces相比有几个字母不同 解析 逐字比较即可 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:1","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"B 题意 给一个二进制数组，问最长的连续的0是多少 解析 枚举寻找 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:2","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"C 题意 一个人可以花时间读【00，01，10，11】四种书，问达成【11】所需要的最少时间是多少？其中【11】既可以通过直接读【11】得到，也可以通过分别读【01，10】得到。 解析 分别枚举两种方式的最少时间，取最小值。 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:3","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"D 题意 设一块金子重量是3x，这块金子能够以分成x和2x的方式被切割，比如6可以被切割为2和4。给定一个n和m，问重为n的金子能否通过切割得到重为m的金子？ 解析 根据题意dfs搜索答案即可，时间复杂度为O($n^{log_23} \\times t$) #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; bool solve(int n, int m) { if(n == m) return true; else { if(n % 3 == 0) { return (solve(n / 3, m) || solve(n / 3 * 2, m)); } else { return false; } } } int main() { int t; cin \u003e\u003e t; while (t --) { int n, m; cin \u003e\u003e n \u003e\u003e m; if(solve(n, m)) cout \u003c\u003c \"yes\"; else cout \u003c\u003c \"no\"; cout \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:4","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"E 题意 给一个n*m的数组，每个数字表示湖的深度，深度为0的地方代表陆地，问最大容量（所有深度之和）的湖有多大？ 解析 用bfs找一下，被访问到的就标记一下，累加一下答案，然后比较最大值即可。 小结一下pair的使用，在一些二元组的场合还是挺方便的。 定义 pair\u003cint,int\u003e p; 嵌套定义 queue\u003cpair\u003cint, int\u003e\u003e q; 生成 make_pair(x,y); 使用 p.first // 第一个变量 p.second // 第二个变量 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; const int x[4] = {0,0,-1,1}; const int y[4] = {1,-1,0,0}; int a[1010][1010]; bool b[1010][1010]; int solve() { int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 1; i \u003c= n; i ++) { for(int j = 1; j \u003c= m; j ++) { cin \u003e\u003e a[i][j]; if(a[i][j] != 0) b[i][j] = true; else b[i][j] = false; } } queue\u003cpair\u003cint, int\u003e\u003e q; int ans = 0; for(int i = 1; i \u003c= n; i ++) { for(int j = 1; j \u003c= m; j ++) { if(!b[i][j]) continue; int now = 0; q.push(make_pair(i, j)); b[i][j] = false; while(!q.empty()) { pair\u003cint, int\u003e p; p = q.front(); now += a[p.first][p.second]; q.pop(); for(int k = 0; k \u003c 4; k ++) { int x1 = p.first + x[k]; // 这里i，j弄错了 int y1 = p.second + y[k]; // 这里first，second弄错了 if(x1 \u003e=1 \u0026\u0026 x1 \u003c= n \u0026\u0026 y1 \u003e=1 \u0026\u0026 y1 \u003c= m \u0026\u0026 b[x1][y1]) { q.push(make_pair(x1, y1)); b[x1][y1] = false; } } } ans = max(ans, now); } } return ans; } int main() { int t; cin \u003e\u003e t; while(t --) { cout \u003c\u003c solve() \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:5","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"F 题意 有一棵树，这棵树只有三层节点，其中父节点只有一个，子结点有x个，孙子结点有y个，给你每个点之间的连接关系，求x和y的值 解析 注意到孙子结点的度只有1，找到度为1的点，然后遍历上去求子节点和父节点的度即可。 虽然父节点的度也可能为1，但其实不影响答案。因为当父节点度为1时，树翻转过来的结构也还是一样的。 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; int x,y; int solve() { int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003e a[n + 10]; int num[n + 10]; memset(num, 0 ,sizeof(num)); for(int i = 1; i \u003c= m; i ++) { int u,v; cin \u003e\u003e u \u003e\u003e v; a[u].push_back(v); a[v].push_back(u); num[u] ++; num[v] ++; } for(int i = 1; i \u003c= n; i ++) { if(num[i] == 1) { for(int j = 0; j \u003c a[i].size(); j ++) { if(num[a[i][j]] != 1) { y = num[a[i][j]] - 1; for(int k = 0; k \u003c a[a[i][j]].size(); k ++) { if(num[a[a[i][j]][k]] != 1) { x = num[a[a[i][j]][k]]; } if(y == 0) x = 1; } } } break; } } } int main() { int t; cin \u003e\u003e t; while(t --) { x = 0, y = 0; solve(); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; } return 0; } 看了一下官方题解的做法，也是相近的，就是计算每个点的度，度为x的点只有1个，度为y+1的点有x个，度为1的点有x*y个。 不过当x=y+1的时候有特殊情况。度为y+1的点有x个，度为1的点有x*y个。 根据这两种情况解二元方程就可以了。 ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:6","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"G 题意 有一些罐头按序号从上到下堆成金字塔形，拿掉其中一个，在他上面的罐头都会倒塌，问拿掉那个罐头后倒塌的所有的序号的平方和时多少？ 解析 一开始我是一位搜索能够的，直接写了个搜索，结果T了，然后比赛时间也到了，就结束了。然后定睛一看O($n \\times t$)已经到$10 ^ 9$的数量级了，一般情况超过了$10^8$就会超时，记错了。后面一看完全可以写个dp，状态转移方程也很简单，运用了一下容斥原理也可以得到。 dp [i，j] 表示推倒第i行第j个罐子所得到的序号平方和，状态转移方程为： $$dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + a[i][j] * a[i][j] - dp[i - 2][j - 1]$$ 之前写的搜索就是注释的那些，其实写记忆化搜索也可以减少重复查询，应该也能过，不过懒得写了。 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; vector\u003cLL\u003e a[2100]; LL dp[2100][2100]; bool b[2100][2100]; // LL cal(int x, int y) // { // if(!b[x][y]) return 0; // if(x \u003c 1 || y \u003e= a[x].size() || y \u003c 0) return 0; // LL ans = a[x][y] * a[x][y]; // b[x][y] = false; // 这个弄反了？ // if(b[x - 1][y]) ans += cal(x - 1, y); // if(b[x - 1][y - 1]) ans += cal(x - 1, y - 1); // // 对于dfs，计算过程不写在return里方便debug // return ans; // } LL solve() { int n; cin \u003e\u003e n; memset(b,true,sizeof(b)); for(int i = 1; i \u003c= 2023; i ++) { for(int j = 0; j \u003c a[i].size(); j ++) { if(a[i][j] == n) { // return cal(i ,j); return dp[i][j]; } } } } int main() { LL p1,p2; p1 = p2 = 0; for(int i = 1; i \u003c= 2023; i ++) { p1 ++; for(int j = 0; j \u003c p1; j ++) { p2 ++; a[i].push_back(p2); } } dp[1][0] = 1; for(int i = 2; i \u003c= 2023; i ++) { dp[i][0] = dp[i - 1][0] + a[i][0] * a[i][0]; for(int j = 1; j \u003c a[i].size(); j ++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + a[i][j] * a[i][j] - dp[i - 2][j - 1]; } } int t; cin \u003e\u003e t; while(t --) { cout \u003c\u003c solve() \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:7","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["codeforces"],"content":"H 这道题是赛后补上的，对于这种用到位运算的题一直没啥头绪，虽然题目意思很简单 题意 给一个包含n个正整数的数组，这个数不超过63。可以任去一段子序列，对序列内的数进行AND（按位与），问运算后的二进制数刚好有k个1的方案有几种？ 解析 由于数组的数非常小，可以考虑用dp直接存每个数的方案数,然后再求和刚好有k个1的数的方案数。 dp[i,j]表示数组取前i个数能得到结果为j的方案数 那么分三种情况 直接在第i个数开始一个新子序列，那么 $dp[i][a[i]] ++$ 我们不取第i个数做按位与，那么$dp[i][a[i]] += dp[i - 1][a[i]]$ 我们取第i个数做按位与，那么$dp[i][a[i] \u0026 j] += dp[i - 1][j]$ __builtin_popcount(mask) // 就是求这个数的二进制表达有多少个1的一个函数 一般碰到这种要mod大数字的题，我都会考虑采用long long，但看题解非常自信的没有用，每一处可能超的地方都做好了mod限制，这是我需要学习的地方。 #include\u003cbits/stdc++.h\u003e #define pi acos(1.0) #define e exp(-1.0) using namespace std; typedef long long LL; const int mod = 1e9 + 7; int solve() { int n, k; cin \u003e\u003e n \u003e\u003e k; vector\u003cint\u003e a(n + 1); vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(1 \u003c\u003c 6, 0)); for(int i = 1; i \u003c= n; i ++) { cin \u003e\u003e a[i]; for(int mask = 0; mask \u003c (1 \u003c\u003c 6); mask ++) { dp[i][mask] += dp[i - 1][mask]; if(dp[i][mask] \u003e= mod) dp[i][mask] -= mod; dp[i][mask \u0026 a[i]] += dp[i - 1][mask]; if(dp[i][mask \u0026 a[i]] \u003e= mod) dp[i][mask \u0026 a[i]] -= mod; } dp[i][a[i]] = (dp[i][a[i]] + 1) % mod; } int ans = 0; for(int mask = 0; mask \u003c (1 \u003c\u003c 6); mask ++) { if(__builtin_popcount(mask) == k) { ans = (ans + dp[n][mask]) % mod; } } return ans; } int main() { int t; cin \u003e\u003e t; while(t --) { cout \u003c\u003c solve() \u003c\u003c endl; } return 0; } ","date":"2023-05-12","objectID":"/cf871%E5%B0%8F%E7%BB%93/:0:8","tags":["dp","dfs","bfs"],"title":"Codeforces Round 871 (Div. 4)小结","uri":"/cf871%E5%B0%8F%E7%BB%93/"},{"categories":["翻译"],"content":"I recently shifted from my home town to Delhi – the country’s capital. When I was in my town, I missed Delhi. When I am in Delhi now, I miss my home town. 最近我离开家乡来到德里-国家的首都。当我在我的家乡时，我想去德里，可当我真正在德里时，我想念我的家乡。 You ask why? Why I wanted to move to Delhi is a story for another day. But I will tell you why I desire to move back to my small and still home town. 你问我为什么？ 我为什么想去德里改天再说吧，但是我想告诉你的时我为什么想从德里回到我的小小的平静的家乡。 Cities and towns have souls of their own. You don’t just live in them; you live with them. If you like their company, things will align themselves to make you successful and happy. But if you don’t like the company, you will keep bumping into the wrong things. Once I liked Delhi’s company. But I am not enjoying it anymore because The bigger the city, the faster its manners of living. When you physically live around people who are in your profession, you constantly feel more competition. Big towns have big people. The bigger the people, the more their gravitational force. My Delhi friends are doing their own big things. And I get sucked into those things willingly or non-willingly. 大城市和小城镇有着他们自己的灵魂。你不是住在他们那里，而是和他们生活在一起。如果你喜欢他们的陪伴，你想做的事情就会和你步调一致，从而使你事业有成，生活愉快。但是如果你不喜欢他们的陪伴，你会不断地遇上那些错误的事情。 我曾喜欢过德里的陪伴，但我现在已经不喜欢了，因为 城市越大，它的生活方式越快。 当你的周围都是和你一样的同行，你会不断地感受到更多的竞争。 大城市里有大人物。这个人越“大”，他就有更多的“地心引力”。我在德里的朋友们总是在做他们自己的“大”事，可我总是自愿或不自愿地被牵扯进这些事情中。 I agreed with Naval Ravikant when he said, “Choosing what city to live in can almost completely determine the trajectory of your life, but we spend so little time trying to figure out what city to live in.” Many people think of moving to a big, more vibrant city when they read Naval’s quote. But I think of moving to a small town. A town that is closer to nature. A town where I can get closer to myself than to other people. 我同意Naval Ravikan（一个企业家）说的，“选择在什么样的城市生活几乎可以完全决定你的生活轨迹，但我们总是不假思索地就决定了我们想要居住的城市。” 当读到Naval的这句话时，很多人想到的是去一个大的，更生机勃勃的城市。但是我想到的是去一个小城镇，一个更接近自然的城镇，一个我可以更接近自我而不是他人的城镇。 所有翻译内容仅供个人学习使用，如涉及侵权，请联系本人删除。 All translated content is for personal study only, in case of infringement, please contact me to delete. 一些生词 align bump manner of livings profession trajectory vibrant ","date":"2023-05-12","objectID":"/%E7%BF%BB%E8%AF%91-%E5%AE%B6%E4%B9%A1/:0:0","tags":[],"title":"Town(家乡) | 翻译","uri":"/%E7%BF%BB%E8%AF%91-%E5%AE%B6%E4%B9%A1/"},{"categories":null,"content":"请洒潘江，各倾陆海云尔 ","date":"2023-03-08","objectID":"/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/hello-world/"}]