<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性表-1</title>
      <link href="/2023/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A81/"/>
      <url>/2023/03/02/%E7%BA%BF%E6%80%A7%E8%A1%A81/</url>
      
        <content type="html"><![CDATA[<h2 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h2><pre><code class="c">#define MaxSize 50typedef struct&#123;  ElemType data[MaxSize];  int length;&#125;SqList;</code></pre><h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><pre><code class="c">#include &lt;stdlib.h&gt; // malloc,free的头文件//定义#define InitSize 10 // 默认的最大长度typedef struct&#123;  int *data; //指示动态分配数组的指针  int MaxSize; // 最大容量  int length; // 当前长度&#125;SeqList;// 初始化void InitList(SeqList &amp;L) &#123;  L.data = (int *)malloc(InitSize * sizeof(int));  L.length = 0;  L.MaxSize = InitSize;&#125;// 增加动态数组的长度void IncreaseSize(SeqList &amp;L, int len) &#123;  int *p = L.data;  L.data = (int *)malloc((L.MaxSize + len) * sizeof(int));  for(int i = 0; i &lt; L.length; i ++) &#123;    L.data[i] = p[i];  &#125;  L.MaxSize = L.MaxSize + len;  free(p);&#125;</code></pre><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><h3 id="vector源码？"><a href="#vector源码？" class="headerlink" title="vector源码？"></a>vector源码？</h3><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><pre><code class="c">bool ListInsert(SqList &amp;L, int i,ElemType e) &#123;  if(i &lt; 1 || i &gt; L.length + 1) retrun false;  if(L.length &gt;= MaxSize) return false;  for(int j = L.length; j &gt;= i; j --) &#123;    L.data[j] = L.data[j - 1];  &#125;  L.data[i - 1] = e;  L.length ++;  return true;&#125;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="c">bool ListDelete(SqList &amp;L, int i, ElemType &amp;e) &#123; //删除第i个元素，用引用变量e返回  if(i &lt; 1 || i &gt; L.length + 1) return false;  e = L.data[i - 1];  for(int j = i; j &lt;= L.length ; j ++) &#123;    L.data[j - 1] = L.data[j];  &#125;  L.length --;  return true;&#125;</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><p>由于顺序表，支持随机访问，使用data[i+1]即可在O(1)时间内找到该元素</p><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><pre><code class="c">int LocateElem(SqList L, ElemType e) &#123;  for(int i = 0; i &lt; L.length; i ++) &#123;    if(L.data[i] == e) return i + 1;  &#125;  return 0;&#125;</code></pre><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="头结点和头指针的区分"><a href="#头结点和头指针的区分" class="headerlink" title="头结点和头指针的区分"></a>头结点和头指针的区分</h2><ul><li>不管有无头节点，头指针始终指向链表的第一个结点</li><li>在有头节点的链表中，头节点的指针指向链表的第一个数据元素<ul><li>头节点的数据域本身不设信息，也可以将其用于记录表长</li><li>引入头节点后，链表第一个位置上的操作和其他位置相同，无需特殊处理</li><li>也统一了空表和非空表的处理</li></ul></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code class="c">typedef struct LNode&#123;  ElemType data;  struct LNode *next; //这里typedef未生效，故写作struct LNode&#125;LNode, *LinkList; //LNode 强调结点 *LinkList 强调链表// 等价写法struct LNode &#123;  ElemType data;  struct LNode *next;&#125;typedef struct LNode LNode;typedef struct LNode *LinkList;// 声明LNode *L;LinkList L;</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="c">bool InitList(LinkList &amp;L) &#123;  L = (LNode *)malloc(sizeof(LNode));  if(L == NULL) return false;  L-&gt;next = NULL;  return true;&#125;</code></pre><h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><pre><code class="c">LinkList ListTailInsert(LinkList &amp;L) &#123;  L = (LinkList)malloc(sizeof(LNode));  LNode *s, *r = L; // r为表尾指针  int x;  scanf(&quot;%d&quot;, &amp;x);  /*不带头节点的情况 第一次输入x时，要将数据赋给头指针  if(x != -1) &#123;    L-&gt;data = x;    scanf(&quot;%d&quot;, &amp;x);  &#125;  */  while(x != -1) &#123; // 输入-1表示结束    s = (LNode *)malloc(sizeof(LNode));    s-&gt;data = x;    r-&gt;next = s;    r = s; // 保持r指向最后一个结点    scanf(&quot;%d&quot;, &amp;x);   &#125;  return L;&#125;</code></pre><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>这种方法建立的链表是倒序的，可以用于实现链表的逆置</p><pre><code class="c">LinkList ListHeadInsert(LinkList &amp;L) &#123;  L = (LinkList)malloc(sizeof(LNode));  L-&gt;next = NULL; // 尾插法中L-&gt;next会被新结点覆盖，故未初始化,最好初始化链表的时候都加上  int x;  scanf(&quot;%d&quot;, &amp;x);  while(x != -1) &#123; // 输入-1表示结束    s = (LNode *)malloc(sizeof(LNode));    s-&gt;data = x;    s-&gt;next = L-&gt;next;    L-&gt;next = s; // 不带头节点的情况 这里应该直接将头指针指向s， L = s;    scanf(&quot;%d&quot;, &amp;x);  &#125;  return L;&#125;</code></pre><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><h3 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h3><pre><code class="c">LNode *LocateElem(LinkList L, ElemType e) &#123;  LNode *p = L-&gt;next;  while(p != NULL &amp;&amp; p-&gt;data != e) p = p-&gt;next;  return p;&#125;</code></pre><h3 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h3><pre><code class="c">LNode *GetElem(LinkList L, int i) &#123;  if(i &lt; 0) return NULL;  LNode *p;  int j = 0;  p = L;  while(p != NULL &amp;&amp; j &lt; i) &#123;    p = p-&gt;next;    j ++;  &#125;  return p;&#125;// i = 0 ---&gt; p = L (头指针)// i &gt; 表长 ---&gt; p = NULL</code></pre><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><pre><code class="c">bool ListInsert(LinkList &amp;L, int i, ElemType e) // 后插操作LNode *s = (LNode *)malloc(sizeof(LNode));p = GetElem(L, i - 1);s-&gt;next = p-&gt;next;p-&gt;next = s;// 前插操作// *s与*p的数据域交换，将后插操作转变为前插操作p = GetElem(L, i - 1);s-&gt;next = p-&gt;next;p-&gt;next = s;temp = p-&gt;data;p-&gt;data = s-&gt;data;s-&gt;data = p-&gt;data;</code></pre><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><pre><code class="c">// 通过待删除结点的前驱来删除结点p = GetElem(L, i - 1);q = p-&gt;next;p-&gt;next = q-&gt;next;free(q);// 已经得到待删除结点的指针p，或无法确定待删除结点的前驱// 将后继结点的数据域覆盖到要删除的节点上，来实现节点的删除，类似上述的前插操作// 待删除结点不能是最后一个结点！（没有后继）q = p-&gt;next;p-&gt;data = p-&gt;next-&gt;data;p-&gt;next = q-&gt;next;free(q);</code></pre><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><pre><code class="c">typedef struct DNode&#123;  ElemType data;  struct DNode *prior,*next;&#125;DNode, *DLinkList;</code></pre><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="c">DLinkList L;InitDLinkList(L);//bool InitDLinkList(DLinkList &amp;L) &#123;  L = (DNode*)malloc(sizeof(DNode));  if(L == NULL) return false;  L-&gt;prior = NULL;  L-&gt;next = NULL;  return true;&#125;</code></pre><h2 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h2><pre><code class="c">bool InsertNextDNode(DNode *p, DNode *s) &#123; // 在p的后面插入s  if(p == NULL || s == NULL) return false;  s-&gt;next = p-&gt;next;  if(p-&gt;next != NULL) p-&gt;next-&gt;prior = s; // 当p是队尾结点时，没有后继结点  s-&gt;prior = p;  p-&gt;next = s;  return true;&#125;</code></pre><h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><pre><code class="c">bool DeleteNextNode(DNode *p) &#123; // 删除p的后继结点   if(p == NULL) return false;  DNode *q = p-&gt;next;  if(q == NULL) return false;  p-&gt;next = q-&gt;next;  if(q-&gt;next != NULL) q-&gt;next-&gt;prior = p;  free(q);  return true;&#125;</code></pre><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><p>链表不具备随机存取的特性，查找操作只能通过顺序遍历实现，实现方式与单链表实现方式相似<br>根据遍历的方式，可分为前向遍历和后向遍历</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><pre><code class="c">while(p != NULl) &#123; // 后向遍历  p = p-&gt;next;&#125;while(p-&gt;prior != NULL) &#123; // 前向遍历，跳过头节点  p = p-&gt;prior;&#125;</code></pre><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>静态链表是借助数组来描述线性表的链式存储结构，通常用在不支持指针的语言中（如basic）<br>以next &#x3D;&#x3D; -1 代表NULL</p><pre><code class="c">#define MaxSize 10typedef struct Node&#123;  ElemType data;  int next;&#125; SLinkList[MaxSize];// 声明SLinkList a;struct Node b[MaxSize]; // a,b等价</code></pre><p><img src="/%E7%BA%BF%E6%80%A7%E8%A1%A81/Pasted%20image%2020230302090726.png"></p><h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>把表尾结点的next指针指向头节点，把表头结点的prior指针指向尾结点</p><h1 id="顺序表与链表比较"><a href="#顺序表与链表比较" class="headerlink" title="顺序表与链表比较"></a>顺序表与链表比较</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>都属于线性表，都是线性结构</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序表：顺序存储"><a href="#顺序表：顺序存储" class="headerlink" title="顺序表：顺序存储"></a>顺序表：顺序存储</h3><p>优点：支持随机存取，存储密度高<br>缺点：大片连续空间分配不方便，改变容量不方便</p><h3 id="链表：链式存储"><a href="#链表：链式存储" class="headerlink" title="链表：链式存储"></a>链表：链式存储</h3><p>优点：离散的小空间分配方便，改变容量方便<br>缺点：不可随机存取，存储密度低</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>对于数据结构的复习思路：创建销毁，增删改查</strong></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>顺序表：需要预分配大片连续空间，若分配空间国小，则之后不方便拓展容量，若分配空间过大，则浪费内存空间<br>链表：只需分配一个头节点（也可以不要头节点，只声明一个头指针），之后方便拓展</p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>顺序表：<br>    1. 静态分配：静态数组–系统自动回收<br>    2. 动态分配（malloc与free成对出现）–需要手动free<br>链表：依次删除各个结点（free)</p><h3 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h3><p>顺序表：插入&#x2F;删除元素要将后续元素都后移&#x2F;前移，时间复杂度O(n)，时间开销主要来自移动元素（若数据元素大，则移动的时间代价很高）<br>链表：插入&#x2F;删除元素只需要修改指针，时间复杂度O(n)，时间开销主要来自查找目标元素（查找元素的时间代价更低）</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>顺序表：按位查找 O(1) 按值查找 O(n)<br>– 当顺序表有序时，按值查找为O(logn)<br>链表： 按位查找 O(n)  按值查找 O(n)</p><h2 id="何时使用顺序表？何时使用链表？"><a href="#何时使用顺序表？何时使用链表？" class="headerlink" title="何时使用顺序表？何时使用链表？"></a>何时使用顺序表？何时使用链表？</h2><p>表长难以预估，经常需要增加&#x2F;删除元素 –链表<br>表长可预估，查询（搜索）操作较多 – 顺序表</p><h2 id="开放式问题的答题思路"><a href="#开放式问题的答题思路" class="headerlink" title="开放式问题的答题思路"></a>开放式问题的答题思路</h2><p>问题：请描述顺序表和链表的…，实现xxx时，用顺序表还是链表？<br>顺序表和链表的逻辑结构都是<strong>线性结构</strong>，都属于线性表。<br>但是二者的存储结构不同，顺序表采用顺序存储（特点，带来的优缺点）；链表采用链式存储…（特点，带来的优缺点）。<br>由于采用不同的存储方式实现，因此基本操作的实现效率也不同。当初始化时…；当插入一个数据元素时…；当删除一个数据元素时；当查找一个数据元素时…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外置大脑</title>
      <link href="/2023/02/22/%E5%A4%96%E7%BD%AE%E5%A4%A7%E8%84%91/"/>
      <url>/2023/02/22/%E5%A4%96%E7%BD%AE%E5%A4%A7%E8%84%91/</url>
      
        <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="win10下terminal单次代理"><a href="#win10下terminal单次代理" class="headerlink" title="win10下terminal单次代理"></a>win10下terminal单次代理</h2><pre><code class="cmd">set http_proxy=http://127.0.0.1:1081set https_proxy=http://127.0.0.1:1081// 测试curl https://www.google.com</code></pre><p>ping命令使用的是ICMP协议，而这里只代理了http的端口，故使用curl测试</p><h2 id="git中对github代理"><a href="#git中对github代理" class="headerlink" title="git中对github代理"></a>git中对github代理</h2><pre><code class="bash">git config --global http.https://github.com.proxy socks5://127.0.0.1:51837// 取消代理git config --global --unset http.proxy git config --global --unset https.proxy</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指针小结</title>
      <link href="/2023/02/20/%E6%8C%87%E9%92%88%E5%B0%8F%E7%BB%93/"/>
      <url>/2023/02/20/%E6%8C%87%E9%92%88%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>自从2月8号以来已经过去了12天，咕了三次本应该有的学习小结，而真正能整理出来的笔记却只有大约半天的学习量。非常惭愧，还是要端正态度。</p><h2 id="指针使用"><a href="#指针使用" class="headerlink" title="指针使用"></a>指针使用</h2><pre><code class="c">scanf(&quot;%d&quot;, &amp;i); //取地址运算：&amp;运算符取得变量的地址//指针变量就是记录地址的变量int* p = &amp;i;int* p;int *p;//以上两种声明方式等价，意为声明了一个int类型的指针。int k = *p; //*是一个单目运算符，用来访问指针所指向的地址上的变量*p = k + 1;</code></pre><ul><li>变量的值是内存的地址<ul><li>普通变量的值是实际的值</li><li>指针变量的值是具有实际值的变量的地址</li></ul></li></ul><h2 id="指针运用场景"><a href="#指针运用场景" class="headerlink" title="指针运用场景"></a>指针运用场景</h2><h3 id="1-函数返回多个值，某些值只能通过指针返回"><a href="#1-函数返回多个值，某些值只能通过指针返回" class="headerlink" title="1. 函数返回多个值，某些值只能通过指针返回"></a>1. 函数返回多个值，某些值只能通过指针返回</h3><p>传入的参数实际上是需要保存带回结果的变量<br>例：交换两个变量的值</p><pre><code class="c">void swap(int *pa, int *pb) &#123;  int t = *pa;  *pa = *pb;  *pb = t;&#125;</code></pre><h3 id="2-函数返回运算的状态，结果通过指针返回"><a href="#2-函数返回运算的状态，结果通过指针返回" class="headerlink" title="2.函数返回运算的状态，结果通过指针返回"></a>2.函数返回运算的状态，结果通过指针返回</h3><p>返回函数的运算状态，通常的做法是让函数返回特殊的不属于有效范围的值，如0，-1<br>但当任何数值都是有效的可能结果时，就得分开返回（状态通过函数返回值返回，实际值通过指针返回）<br>ps：在C++和Java采用了异常机制来处理这个问题<br>例：一个做除法的函数</p><pre><code class="c">int divide(int a, int b, int *result) &#123;  int ret = 1;  if (b == 0) &#123;    ret = 0;  &#125;  else &#123;    *result = a / b;  &#125;  return ret;&#125;</code></pre><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>数组作为参数传入函数时，实际上传入的是一个指向数组的指针。</p><ul><li>数组变量是特殊的指针<ul><li>int a[10]; int *p &#x3D; a; &#x2F;&#x2F; 不用&amp;取地址</li><li>但是数组的单元表达的是变量，需要用&amp;取地址。</li><li>a &#x3D;&#x3D; &amp;a[0]</li></ul></li><li>[]运算符和*运算符既可以对数组做运算，也可以对指针做运算<ul><li>p[0] &lt;&#x3D;&#x3D;&#x3D;&gt; a[0]</li><li>*a &#x3D; 25 &lt;&#x3D;&#x3D;&#x3D;&gt; a[0] &#x3D; 25;</li></ul></li><li>数组变量是const的指针，所以不能被赋值<ul><li>int a[] &lt;&#x3D;&#x3D;&#x3D;&gt; int * const a &#x3D; ….</li></ul></li></ul><h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><pre><code class="c">// （1）int *const q = &amp;i;*q = 26; // okq ++; // error!// 表示一旦得到了某个变量的地址，指针就不能再指向其他变量 【指针q是const】// (2)const int *p = &amp;i;// 表示不能通过这个指针p去修改变量i（不会使变量i成为const）【指针p所指的变量是const】*P = 26; // error! (*p)是consti = 26; // okp = &amp;j // ok//通过判断const在*前还是后来做区分const int *p1 = &amp;i; // （2）int const* p2 = &amp;i; // （2）int *const p3 = &amp;i; // （1）</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>当要传递的参数类型比地址大的时候，既能用比较少的字节数传递值给参数(特别是在结构体中），又能避免函数对外面的变量的修改</li></ol><pre><code class="c">void f(const int* x);</code></pre><ol start="2"><li>保护数组值，因为把数组传入函数时传递的时地址，所以那个函数内部可以修改数组的值，为了避免数组不被函数修改，可以设置参数为const</li></ol><pre><code class="c">int sum(const int a[],int length);</code></pre><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><pre><code class="c">//给一个指针加一表示要让指针指向下一个变量int a[10];int *p = a;*(p + 1) == a[1];// 如果指针不是指向一片连续分配的空间，如数组，则这种运算没用意义*p ++;//取出p所指的数据，然后把p移到下一个位置（*的优先级小于++）</code></pre><h3 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h3><p>内存中有0地址，但通常指针不应该具有0值。</p><ul><li>因此可以用0地址表示特殊的事情：<ul><li>返回的指针时无效的</li><li>指针没有被真正初始化</li></ul></li><li>NULL时一个预定定义的符号，用来表示0地址</li><li>使用NULL而不是0来表示0地址！</li></ul><h3 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h3><ul><li>void表示不知道指向什么类型的指针</li></ul><pre><code class="c">int *p = &amp;i; void *q - (void*)p; //指针的类型转换//这里并没有改变p所指的变量的类型，而是改变了p指向的类型//p指向了int -&gt; p指向了void</code></pre><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>输入数据时，先给你数据个数n，再给你n个数据，要求你存储这n个数据，该怎么做？</p><pre><code class="c">int *a = (int*) malloc(n * sizeof(int));for(int i = 0; i &lt; n; i ++) &#123;  scanf(&quot;%d&quot;, &amp;a[i]);&#125;free(a);// C99开始可以用变量确定数组的大小,C99之前只能用以上方式</code></pre><ul><li>向malloc申请的空间的大小是以字节为单位的</li></ul><pre><code class="c">#include &lt;stdlib.h&gt;void* malloc(size_t size);</code></pre><ul><li>返回结果时void*。需要将类型转换为自己需要的类型</li><li>如果没空间，申请失败了会返回0，即NULL</li><li>free() 申请来的空间得“还”<ul><li>只能还申请来的空间的首地址</li></ul></li><li>指针定义时最好用NULL做一下初始化，以免它指向奇怪的地方<ul><li>因此free(NULL)是被允许的</li></ul></li></ul><pre><code class="c">free(NULL); //okvoid *p = NULL; // free(p) //ok</code></pre><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>malloc后没free -&gt; <strong>长时间</strong>运行内存逐渐下降</li><li>free过了再free</li><li>地址变了，直接去free</li></ul><blockquote><p><strong>来一碗课程中的鸡汤</strong><br>学计算机一定要有一个非常强大的心理状态，计算机的所有东西都是人做出来的，别人能想出来的，我也一定能想出来，计算机里头没有任何黑魔法，所有的东西只是我现在不知道而已，总有一天我会把所有的细节，所有的内部东西全部搞明白。 <p align="right">– 翁恺老师</p></p></blockquote><br><p>参考资料：<br><a href="https://www.bilibili.com/video/BV1dr4y1n7vA?p=82&vd_source=d73ecc50963e1ff1f97ba67f22cff84c">9.1.2 指针：指针变量就是记录地址的变量_高清 720P_哔哩哔哩_bilibili</a><br><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在开始</title>
      <link href="/2023/02/08/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B/"/>
      <url>/2023/02/08/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>最早写博客应该是在高中搞OI的时候，记录一些不会做的题，大致的创作流程是这样的：<br>搜索网络上的题解-&gt;自己复现一遍-&gt;用自己的话写一遍题解<br>这样的做法比起看到AC就直接pass，多了一个复习总结的过程，知识点掌握得自然就更牢了（尽管现在大多已经忘了）</p><p>回到正题，多年来的学习经验使我意识到，<b>闭门造车式的学习是行不通的</b>。由于笔者是在家自学备战计算机考研11408，一是没有能够互相交流学习的老师同学，二是缺乏一个自我监督的环境。基于此，笔者会将在自己学习过程中的收获输出到这篇博客，以此来监督自己。在家考研是个孤独的过程，希望能借助这个平台，与同学朋友，还有看到这篇博文的志同道合的朋友们一起交流学习。</p><h2 id="我的学习工作流"><a href="#我的学习工作流" class="headerlink" title="我的学习工作流"></a>我的学习工作流</h2><p>在使用了多款管理工具后，我简单确定了自己需要使用的几款工具</p><h3 id="目标管理软件"><a href="#目标管理软件" class="headerlink" title="目标管理软件"></a>目标管理软件</h3><p>尽管市面上有着比微软全家桶更好的各种工具，但微软的几个工具使用起来比较简单，而且能够做到手机PC互通，笔者也比较熟悉，所以我使用outlook来做目标管理。</p><p>用to do 来放一下代办的事情<br><img src="/2023/02/08/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B/Pasted%20image%2020230208201602.png"><br>用日历来做一下时间的规划、安排。<br><img src="/2023/02/08/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B/Pasted%20image%2020230208201830.png"></p><h3 id="笔记软件"><a href="#笔记软件" class="headerlink" title="笔记软件"></a>笔记软件</h3><p>一款是obsidian，网络上给好评的很多，我用它的原因主要是它支持markdown，而我的博客也是通过markdown发布的，这样我做的笔记稍作修改就能发到博客了（真巧）<br>还有就是OneNote，因为它还算能用的多设备同步，以及离不开的微软全家桶…</p><h2 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h2><p>周三的内容应该只包含我复习考研科目的一些笔记<br>周日的内容会参杂一些摸鱼看到的东西？<br>以及不定时发布codeforces、leetcode的题解，还有一些读书笔记</p><h2 id="学习计划（now-3-31）"><a href="#学习计划（now-3-31）" class="headerlink" title="学习计划（now~3.31）"></a>学习计划（now~3.31）</h2><p>过一遍408 + 线性代数（flag先立下了！）</p><p>多说无益，开始学习吧！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/02/hello-world/"/>
      <url>/2023/02/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
